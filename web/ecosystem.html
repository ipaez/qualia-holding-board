<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Qualia Holding Board — Ecosistema</title>
<script src="shared.js"></script>
<style id="shared-css"></style>
<style>
html, body { height: 100%; overflow: hidden; }
.bs-wrap { display: flex; flex-direction: column; height: 100vh; }

/* Board selector bar */
.bs-boards-bar {
  display: flex; align-items: center; gap: 6px; padding: 10px 22px;
  border-bottom: 1px solid var(--border); background: var(--bg-card); flex-shrink: 0;
  overflow-x: auto;
}
.bs-board-tab {
  background: var(--bg-elevated); color: var(--text-tertiary); border: 1px solid var(--border);
  padding: 6px 16px; border-radius: 20px; cursor: pointer;
  font-family: var(--font-body); font-size: 0.78rem; font-weight: 500; transition: all .2s;
  white-space: nowrap; display: flex; align-items: center; gap: 6px;
}
.bs-board-tab:hover { color: var(--text-primary); border-color: var(--border-hover); }
.bs-board-tab.active { background: var(--gold-dim); color: var(--gold); border-color: rgba(201,169,78,0.3); }
.bs-board-tab .tab-count { font-size: 0.65rem; opacity: 0.5; }
/* tab-del removed - delete via options menu only */
.bs-add-board {
  background: transparent; color: var(--text-tertiary); border: 1px dashed var(--border);
  padding: 6px 14px; border-radius: 20px; cursor: pointer;
  font-family: var(--font-body); font-size: 0.78rem; transition: all .2s;
}
.bs-add-board:hover { color: var(--gold); border-color: rgba(201,169,78,0.3); }

/* Breadcrumb */
.bs-breadcrumb {
  display: flex; align-items: center; gap: 6px; padding: 10px 22px;
  border-bottom: 1px solid var(--border); background: var(--bg-card);
  font-family: var(--font-body); font-size: 0.85rem; flex-shrink: 0;
  overflow-x: auto;
}
.bs-breadcrumb .bc-back {
  color: var(--gold); cursor: pointer; display: flex; align-items: center; gap: 4px;
  padding: 4px 10px; border-radius: 6px; border: 1px solid rgba(201,169,78,0.2);
  background: var(--gold-glow); font-size: 0.78rem; font-weight: 600;
  transition: all .15s; margin-right: 6px;
}
.bs-breadcrumb .bc-back:hover { background: var(--gold-dim); border-color: rgba(201,169,78,0.4); }
.bs-breadcrumb .bc-item {
  color: var(--text-secondary); cursor: pointer; transition: all .15s;
  white-space: nowrap; padding: 4px 8px; border-radius: 6px;
  font-weight: 500;
}
.bs-breadcrumb .bc-item:hover { color: var(--gold); background: var(--gold-glow); }
.bs-breadcrumb .bc-sep { color: var(--text-tertiary); opacity: 0.4; font-size: 0.75rem; }
.bs-breadcrumb .bc-current { color: var(--text-primary); font-weight: 700; cursor: default; }
.bs-breadcrumb .bc-current:hover { background: none; color: var(--text-primary); }

/* Toolbar */
.bs-toolbar {
  display: flex; align-items: center; gap: 8px; padding: 8px 22px;
  border-bottom: 1px solid var(--border); background: rgba(17,19,24,0.8); flex-shrink: 0;
}
.bs-toolbar button {
  background: transparent; color: var(--text-secondary); border: 1px solid var(--border);
  padding: 6px 14px; border-radius: var(--radius-sm); cursor: pointer;
  font-family: var(--font-body); font-size: 0.78rem; font-weight: 500; transition: all .2s;
  display: flex; align-items: center; gap: 5px;
}
.bs-toolbar button svg { width: 13px; height: 13px; }
.bs-toolbar button:hover { background: var(--gold-glow); color: var(--gold); border-color: rgba(201,169,78,0.3); }
.bs-toolbar button.active { background: var(--gold-dim); color: var(--gold); border-color: rgba(201,169,78,0.3); }
.bs-toolbar .spacer { flex: 1; }
.bs-toolbar .zoom-label { font-size: 0.7rem; color: var(--text-tertiary); font-family: var(--font-mono); min-width: 40px; text-align: right; }

/* Board options menu */
.bs-opts-wrap { position: relative; }
.bs-opts-btn {
  background: transparent; color: var(--text-tertiary); border: 1px solid var(--border);
  width: 32px; height: 32px; border-radius: var(--radius-sm); cursor: pointer;
  display: flex; align-items: center; justify-content: center; transition: all .2s;
}
.bs-opts-btn:hover { color: var(--text-primary); background: var(--bg-elevated); border-color: var(--border-hover); }
.bs-opts-btn.open { color: var(--gold); background: var(--gold-glow); border-color: rgba(201,169,78,0.3); }
.bs-opts-menu {
  display: none; position: absolute; top: 100%; right: 0; margin-top: 6px;
  background: var(--bg-card); border: 1px solid var(--border); border-radius: 10px;
  min-width: 180px; z-index: 50; overflow: hidden;
  box-shadow: 0 12px 40px rgba(0,0,0,0.5);
}
.bs-opts-menu.open { display: block; }
.bs-opts-menu button {
  display: flex; align-items: center; gap: 8px; width: 100%;
  background: none; border: none; color: var(--text-secondary);
  padding: 10px 16px; cursor: pointer; font-family: var(--font-body);
  font-size: 0.8rem; transition: all .15s; text-align: left;
}
.bs-opts-menu button:hover { background: var(--bg-elevated); color: var(--text-primary); }
.bs-opts-menu button.danger { color: var(--red); }
.bs-opts-menu button.danger:hover { background: rgba(248,113,113,0.08); }
.bs-opts-menu button svg { width: 15px; height: 15px; flex-shrink: 0; }
.bs-opts-sep { height: 1px; background: var(--border); margin: 4px 0; }

.bs-board-name {
  background: transparent; border: none; color: var(--text-primary); font-family: var(--font-heading);
  font-size: 0.95rem; font-weight: 700; padding: 4px 8px; border-radius: 6px; transition: background .2s;
  min-width: 120px;
}
.bs-board-name:hover { background: var(--bg-elevated); }
.bs-board-name:focus { background: var(--bg-elevated); outline: none; border: none; }

.canvas-wrap { flex: 1; position: relative; overflow: hidden; }
canvas#bsCanvas { display: block; width: 100%; height: 100%; cursor: grab; }
canvas#bsCanvas.dragging { cursor: grabbing; }
canvas#bsCanvas.connecting { cursor: crosshair; }

/* Empty state */
.bs-empty {
  position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
  text-align: center; color: var(--text-tertiary); pointer-events: none;
}
.bs-empty svg { width: 48px; height: 48px; opacity: 0.2; margin-bottom: 12px; }
.bs-empty p { font-family: var(--font-body); font-size: 0.85rem; margin: 4px 0; }
.bs-empty .hint { font-size: 0.72rem; opacity: 0.5; }

/* Side Panel */
.side-panel {
  position: absolute; top: 0; right: 0; width: 400px; height: 100%;
  background: var(--bg-card); border-left: 1px solid var(--border);
  transform: translateX(100%); transition: transform .3s cubic-bezier(0.4,0,0.2,1); z-index: 10;
  display: flex; flex-direction: column; overflow-y: auto;
  box-shadow: -20px 0 60px rgba(0,0,0,0.5);
}
.side-panel.open { transform: translateX(0); }
.sp-header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 20px 24px; border-bottom: 1px solid var(--border); flex-shrink: 0;
}
.sp-header h3 { font-family: var(--font-heading); font-size: 1rem; font-weight: 700; color: var(--gold); }
.sp-saved { font-size: 0.7rem; color: var(--green); opacity: 0; transition: opacity .3s; margin-left: 8px; font-family: var(--font-body); }
.sp-saved.show { opacity: 1; }
.sp-close {
  background: none; border: 1px solid var(--border); color: var(--text-tertiary);
  width: 30px; height: 30px; border-radius: 8px; cursor: pointer;
  display: flex; align-items: center; justify-content: center; transition: all .2s;
}
.sp-close:hover { color: var(--text-primary); background: var(--bg-elevated); }
.sp-body { padding: 20px 24px; flex: 1; }
.sp-body label {
  display: block; font-family: var(--font-heading); font-size: 0.62rem; font-weight: 700;
  color: var(--text-tertiary); margin: 18px 0 6px; text-transform: uppercase; letter-spacing: 2.5px;
}
.sp-body label:first-child { margin-top: 0; }
.sp-body input, .sp-body textarea, .sp-body select {
  width: 100%; background: var(--bg-base); color: var(--text-primary);
  border: 1px solid var(--border); padding: 10px 14px;
  border-radius: var(--radius-sm); font-family: var(--font-body); font-size: 0.85rem;
  transition: border-color .2s;
}
.sp-body textarea { min-height: 80px; resize: vertical; line-height: 1.5; }
.sp-body input:focus, .sp-body textarea:focus { outline: none; border-color: var(--gold); box-shadow: 0 0 0 3px var(--gold-glow); }
.sp-body .color-row { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
.sp-body .color-swatch {
  width: 28px; height: 28px; border-radius: 8px; cursor: pointer; border: 2px solid transparent;
  transition: all .15s;
}
.sp-body .color-swatch:hover { transform: scale(1.15); }
.sp-body .color-swatch.active { border-color: #fff; box-shadow: 0 0 8px rgba(255,255,255,0.2); }
.sp-tags-wrap { display: flex; gap: 5px; flex-wrap: wrap; margin-top: 4px; }
.sp-tag {
  display: inline-flex; align-items: center; gap: 4px;
  background: var(--gold-dim); color: var(--gold); font-size: 0.72rem; font-family: var(--font-body);
  padding: 3px 10px; border-radius: 20px; font-weight: 600;
}
.sp-tag button { background: none; border: none; color: var(--gold); cursor: pointer; font-size: 13px; padding: 0; opacity: 0.5; }
.sp-tag button:hover { opacity: 1; }
.sp-tag-add { display: flex; gap: 6px; margin-top: 6px; }
.sp-tag-add input { flex: 1; padding: 6px 10px; font-size: 0.78rem; }
.sp-tag-add button {
  background: var(--bg-elevated); border: 1px dashed var(--border); color: var(--text-tertiary);
  padding: 6px 10px; border-radius: var(--radius-sm); cursor: pointer; font-size: 0.72rem; transition: all .2s;
}
.sp-tag-add button:hover { color: var(--gold); border-color: rgba(201,169,78,0.3); }
.sp-conns { margin-top: 4px; }
.sp-conn-item {
  display: flex; align-items: center; gap: 8px; padding: 7px 10px;
  border-radius: 8px; font-size: 0.8rem; color: var(--text-secondary);
  transition: background .15s; margin: 2px 0; font-family: var(--font-body);
}
.sp-conn-item:hover { background: var(--bg-elevated); }
.sp-conn-item .del { margin-left: auto; opacity: 0; cursor: pointer; color: var(--red); font-size: 14px; transition: opacity .15s; }
.sp-conn-item:hover .del { opacity: 0.6; }
.sp-conn-item .del:hover { opacity: 1; }
.sp-footer { padding: 16px 24px; border-top: 1px solid var(--border); display: flex; gap: 8px; flex-shrink: 0; }
.sp-footer button {
  flex: 1; padding: 10px; border: none; border-radius: var(--radius-sm);
  cursor: pointer; font-family: var(--font-body); font-weight: 600; font-size: 0.82rem; transition: all .2s;
}
.sp-footer .btn-del { background: rgba(248,113,113,.08); color: var(--red); border: 1px solid rgba(248,113,113,.15); }
.sp-footer .btn-del:hover { background: rgba(248,113,113,.15); }

/* Ref picker modal */
.ref-picker-overlay {
  display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0,0,0,0.6); z-index: 100; align-items: center; justify-content: center;
}
.ref-picker-overlay.open { display: flex; }
.ref-picker {
  background: var(--bg-card); border: 1px solid var(--border); border-radius: 16px;
  width: 480px; max-height: 70vh; display: flex; flex-direction: column;
  box-shadow: 0 20px 60px rgba(0,0,0,0.6); overflow: hidden;
}
.ref-picker h3 {
  font-family: var(--font-heading); font-size: 1rem; font-weight: 700; color: var(--gold);
  padding: 20px 24px 12px; margin: 0;
}
.ref-picker .rp-search {
  margin: 0 24px 12px; padding: 10px 14px; background: var(--bg-base); border: 1px solid var(--border);
  border-radius: var(--radius-sm); color: var(--text-primary); font-family: var(--font-body); font-size: 0.85rem;
}
.ref-picker .rp-search:focus { outline: none; border-color: var(--gold); }
.ref-picker .rp-list { flex: 1; overflow-y: auto; padding: 0 12px 16px; }
.ref-picker .rp-board-name {
  font-family: var(--font-heading); font-size: 0.65rem; font-weight: 700; text-transform: uppercase;
  letter-spacing: 2px; color: var(--text-tertiary); padding: 12px 12px 6px; margin: 0;
}
.ref-picker .rp-card {
  display: flex; align-items: center; gap: 10px; padding: 10px 12px; border-radius: 10px;
  cursor: pointer; transition: background .15s; margin: 2px 0;
}
.ref-picker .rp-card:hover { background: var(--bg-elevated); }
.ref-picker .rp-card .rp-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
.ref-picker .rp-card .rp-info { flex: 1; min-width: 0; }
.ref-picker .rp-card .rp-title { font-family: var(--font-body); font-size: 0.85rem; color: var(--text-primary); font-weight: 500; }
.ref-picker .rp-card .rp-summary { font-family: var(--font-body); font-size: 0.72rem; color: var(--text-tertiary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.ref-picker .rp-card .rp-principal { font-size: 0.6rem; color: var(--gold); font-weight: 700; font-family: var(--font-heading); text-transform: uppercase; letter-spacing: 1.5px; }
.ref-picker .rp-cancel {
  margin: 12px 24px 16px; padding: 10px; background: var(--bg-elevated); border: 1px solid var(--border);
  border-radius: var(--radius-sm); color: var(--text-secondary); cursor: pointer;
  font-family: var(--font-body); font-size: 0.82rem; text-align: center; transition: all .2s;
}
.ref-picker .rp-cancel:hover { color: var(--text-primary); background: var(--bg-base); }

@media (max-width: 700px) {
  .side-panel { width: 100%; border-left: none; top: auto; bottom: 0; height: 70%; transform: translateY(100%); }
  .side-panel.open { transform: translateY(0); }
}
</style>
</head>
<body>
<script>document.getElementById('shared-css').textContent = getSharedCSS();</script>
<script>document.write(getNavHTML('ecosystem'));</script>
<div class="qb-main" style="height:100vh">
<div class="bs-wrap">
  <div class="bs-boards-bar" id="boardsBar"></div>
  <div class="bs-breadcrumb" id="breadcrumb" style="display:none"></div>
  <div class="bs-toolbar">
    <input class="bs-board-name" id="boardName" value="" placeholder="Nombre del board...">
    <div style="width:1px;height:20px;background:var(--border);margin:0 6px"></div>
    <button id="btnAdd"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="9"/><line x1="12" y1="8" x2="12" y2="16"/><line x1="8" y1="12" x2="16" y2="12"/></svg> Nodo</button>
    <button id="btnConn"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 8A2 2 0 1 0 18 4a2 2 0 0 0 0 4zM6 20a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/><path d="M18 8c-3 0-6 4-12 8"/></svg> Conectar</button>
    <div class="spacer"></div>
    <span class="zoom-label" id="zoomLabel">100%</span>
    <button id="btnReset"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M3 12h3m12 0h3M12 3v3m0 12v3"/></svg></button>
    <div class="bs-opts-wrap">
      <button class="bs-opts-btn" id="optsBtn" title="Opciones del board"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><circle cx="12" cy="5" r="1.5"/><circle cx="12" cy="12" r="1.5"/><circle cx="12" cy="19" r="1.5"/></svg></button>
      <div class="bs-opts-menu" id="optsMenu">
        <button onclick="renameboardPrompt()"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 3a2.83 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5z"/></svg> Renombrar board</button>
        <button onclick="duplicateBoard()"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg> Duplicar board</button>
        <div class="bs-opts-sep"></div>
        <button class="danger" onclick="deleteBoardConfirm()"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg> Eliminar board</button>
      </div>
    </div>
  </div>
  <div class="canvas-wrap">
    <canvas id="bsCanvas"></canvas>
    <div class="bs-empty" id="emptyState">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M12 2a7 7 0 0 1 5 11.9V16a1 1 0 0 1-1 1H8a1 1 0 0 1-1-1v-2.1A7 7 0 0 1 12 2z"/><line x1="9" y1="21" x2="15" y2="21"/></svg>
      <p>Sin nodos todavia</p>
      <p class="hint">Click "+ Nodo" para empezar</p>
    </div>
    <div class="side-panel" id="sidePanel">
      <div class="sp-header">
        <h3 id="spTitle">Nodo</h3>
        <span class="sp-saved" id="spSaved">Guardado</span>
        <button class="sp-close" id="spClose"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button>
      </div>
      <div class="sp-body">
        <label>Nombre</label>
        <input type="text" id="spName">
        <label>Descripcion</label>
        <textarea id="spDesc" style="min-height:60px"></textarea>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px">
          <div><label>Stage</label><select id="spStage"><option value="idea">Idea</option><option value="desarrollo">Desarrollo</option><option value="mvp">MVP</option><option value="activo">Activo</option><option value="escalando">Escalando</option><option value="escritura">Escritura</option><option value="pausado">Pausado</option></select></div>
          <div><label>Revenue</label><input type="text" id="spRevenue" placeholder="Pre-revenue, $2k/mo..."></div>
        </div>
        <label>Agente</label>
        <input type="text" id="spAgent" placeholder="QualIA, InfraQual-IA...">
        <label>Objetivo</label>
        <textarea id="spObj" style="min-height:60px"></textarea>
        <label>Notas</label>
        <textarea id="spNotes" style="min-height:80px"></textarea>
        <label>Metricas</label>
        <div id="spMetrics" class="sp-tags-wrap"></div>
        <div class="sp-tag-add"><input type="text" id="spMetricLabel" placeholder="Label..."><input type="text" id="spMetricVal" placeholder="Valor..."><button id="spMetricAdd">+</button></div>
        <label>Proyecto asociado</label>
        <div id="spProjectWrap"></div>
        <div id="spTaskSection" style="display:none">
          <label id="spTaskLabel">Tareas</label>
          <div id="spTaskList" class="sp-conns" style="max-height:200px;overflow-y:auto"></div>
          <a id="spTaskLink" href="#" style="display:none;margin-top:6px;font-size:0.78rem;color:var(--gold);text-decoration:none">Ver en Proyectos &rarr;</a>
        </div>
        <label>Color</label>
        <div class="color-row" id="spColors"></div>
        <label>Sub-nodos</label>
        <div class="sp-conns" id="spRefs"></div>
        <button id="spAddRef" style="margin-top:6px;background:var(--gold-dim);color:var(--gold);border:none;padding:8px 14px;border-radius:var(--radius-sm);cursor:pointer;font-family:var(--font-body);font-size:0.78rem;font-weight:600;transition:all .2s;width:100%">+ Agregar sub-nodo</button>
        <label>Conexiones</label>
        <div class="sp-conns" id="spConns"></div>
      </div>
      <div class="sp-footer">
        <button class="btn-del" id="spDelete">Eliminar nodo</button>
      </div>
    </div>
    <!-- Connection detail panel -->
    <div class="side-panel" id="connPanel">
      <div class="sp-header">
        <h3 id="cpTitle">Conexion</h3>
        <span class="sp-saved" id="cpSaved">Guardado</span>
        <button class="sp-close" id="cpClose"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button>
      </div>
      <div class="sp-body">
        <label>Desde</label>
        <div id="cpFrom" style="padding:8px 14px;background:var(--bg-base);border-radius:var(--radius-sm);font-size:0.85rem;color:var(--text-secondary);border:1px solid var(--border)"></div>
        <label>Hacia</label>
        <div id="cpTo" style="padding:8px 14px;background:var(--bg-base);border-radius:var(--radius-sm);font-size:0.85rem;color:var(--text-secondary);border:1px solid var(--border)"></div>
        <label>Etiqueta</label>
        <input type="text" id="cpLabel">
        <label>Detalle / Explicacion</label>
        <textarea id="cpDetail" style="min-height:160px" placeholder="Describe la relacion entre estas ideas..."></textarea>
      </div>
      <div class="sp-footer">
        <button class="btn-del" id="cpDelete">Eliminar conexion</button>
      </div>
    </div>
  </div>
  <!-- Ref picker modal -->
  <div class="ref-picker-overlay" id="refPickerOverlay">
    <div class="ref-picker">
      <h3>Agregar sub-nodo</h3>
      <input class="rp-search" id="rpSearch" placeholder="Buscar idea..." type="text">
      <div class="rp-list" id="rpList"></div>
      <div class="rp-cancel" id="rpCancel">Cancelar</div>
    </div>
  </div>
</div>

<script>
const ECO_BAPI = 'api/ecosystem';
const COLORS = ['#c9a94e','#3498db','#2ecc71','#e74c3c','#9b59b6','#e67e22','#1abc9c','#e056a0','#f39c12','#06d6d6'];
const CARD_W = 280, CARD_H = 140, CARD_R = 14;
const SUB_ROW_H = 26; // height per sub-card row inside parent

let boards = [], currentBoard = null;
let canvas, ctx, W, H, dpr;
let scale = 1, panX = 0, panY = 0;
let dragCard = null, dragOffX = 0, dragOffY = 0, didDrag = false;
let isPanning = false, panSX = 0, panSY = 0, panSPX = 0, panSPY = 0;
let selectedCard = null, hoverCard = null, hoverConn = null, selectedConn = null;
let hoverRef = null, hoverProject = null; // {card, refIndex} when hovering over a sub-card row
let connectMode = false, connectFrom = null, connectMX = null, connectMY = null;
let particles = [];
let time = 0, saveTimer = null, connSaveTimer = null;
// Resolved ref data cache: { "boardId:cardId": {title, summary, color, boardName, ...} }
let refCache = {};

async function init() {
  canvas = document.getElementById('bsCanvas');
  ctx = canvas.getContext('2d');
  resize();
  window.addEventListener('resize', resize);
  await loadBoards();
  const parsed = parseHash();
  const ids = parsed.ids;
  if (ids.length > 0) {
    const targetId = ids[ids.length - 1];
    const parentIds = ids.slice(0, -1);
    navPath = [];
    for (let i = 0; i < parentIds.length; i++) {
      const pid = parentIds[i];
      const b = boards.find(b => b.id === pid);
      navPath.push({ id: pid, name: b?.name || pid, focusNodeId: null });
    }
    const found = boards.find(b => b.id === targetId);
    if (found) { await selectBoard(found.id, parsed.focusCardId); } else { autoSelect(); }
  } else {
    autoSelect();
    // Set initial hash to current board
    if (currentBoard) location.replace('#' + currentBoard.id);
  }
  bindEvents();
  animate();
}

function autoSelect() {
  if (boards.length > 0) selectBoard(boards[0].id);
  else renderBoardTabs();
}

function resize() {
  const wrap = canvas.parentElement;
  dpr = window.devicePixelRatio || 1;
  W = wrap.clientWidth; H = wrap.clientHeight;
  canvas.width = W * dpr; canvas.height = H * dpr;
  canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

// --- Data ---
async function loadBoards() {
  boards = await fetch(`${ECO_BAPI}/boards`).then(r => r.json());
}

// --- Navigation via hash: #boardId or #boardId@focusNodeId ---
// Hash encodes the full path: #root/demos/sub-board
// Back button works natively via browser history

let navPath = []; // [{id, name}] - full path from root to current board

function buildHash() {
  const parts = navPath.map(p => p.id);
  if (currentBoard) parts.push(currentBoard.id);
  return '#' + parts.join('/');
}

// Parse hash: segments are boardId or boardId@focusCardId
// Returns { ids: string[], focusCardId: string|null }
function parseHash() {
  const h = location.hash.replace('#', '');
  if (!h) return { ids: [], focusCardId: null };
  const segments = h.split('/');
  // Check last segment for @focusCardId
  const last = segments[segments.length - 1];
  let focusCardId = null;
  if (last.includes('@')) {
    const [boardPart, cardPart] = last.split('@');
    segments[segments.length - 1] = boardPart;
    focusCardId = cardPart || null;
  }
  return { ids: segments, focusCardId };
}

// drillIntoBoard: set the hash, hashchange does the rest
// sourceNodeId: node in current board that initiated drill (for back navigation)
// targetFocusCardId: card in target board to center on
function drillIntoBoard(id, sourceNodeId, targetFocusCardId) {
  if (currentBoard) {
    navPath.push({ id: currentBoard.id, name: currentBoard.name, focusNodeId: sourceNodeId || null });
  }
  const parts = navPath.map(p => p.id);
  const lastSegment = targetFocusCardId ? id + '@' + targetFocusCardId : id;
  parts.push(lastSegment);
  location.hash = '#' + parts.join('/');
}

function navigateBreadcrumb(index) {
  const target = navPath[index];
  navPath = navPath.slice(0, index);
  const parts = navPath.map(p => p.id);
  // Include focusNodeId so we center on the originating node when going back
  const lastSegment = target.focusNodeId ? target.id + '@' + target.focusNodeId : target.id;
  parts.push(lastSegment);
  location.hash = '#' + parts.join('/');
}

let _navBusy = false;
window.addEventListener('hashchange', async () => {
  if (_navBusy) return;
  _navBusy = true;
  try {
    const parsed = parseHash();
    const ids = parsed.ids;
    if (ids.length === 0) { _navBusy = false; return; }

    const targetId = ids[ids.length - 1];
    // focusCardId from hash (e.g. boardId@cardId)
    let focusNodeId = parsed.focusCardId || null;

    // Rebuild navPath from hash
    const parentIds = ids.slice(0, -1);
    const newPath = [];
    for (let i = 0; i < parentIds.length; i++) {
      const pid = parentIds[i];
      const b = boards.find(b => b.id === pid);

      // Preserve focusNodeId from old navPath if available
      const existing = navPath.find(p => p.id === pid);
      let fid = existing?.focusNodeId || null;

      // If not cached, look up which node in this board links to the child
      if (!fid && b) {
        const childId = ids[i + 1];
        const full = await fetch(`${ECO_BAPI}/boards/${pid}`).then(r => r.json());
        const node = (full.nodes || []).find(n => n.boardId === childId);
        if (node) fid = node.id;
      }

      newPath.push({ id: pid, name: b?.name || pid, focusNodeId: fid });
    }

    // If no focusCardId in hash and going back, try to find the origin node
    if (!focusNodeId && newPath.length < navPath.length) {
      const oldNextId = navPath[newPath.length]?.id;
      if (oldNextId) {
        const full = await fetch(`${ECO_BAPI}/boards/${targetId}`).then(r => r.json());
        const originNode = (full.nodes || []).find(n => n.boardId === oldNextId);
        if (originNode) focusNodeId = originNode.id;
      }
    }

    navPath = newPath;
    await selectBoard(targetId, focusNodeId);
  } finally {
    _navBusy = false;
  }
});

function renderBreadcrumb() {
  const el = document.getElementById('breadcrumb');
  if (navPath.length === 0) {
    el.style.display = 'none';
    return;
  }
  el.style.display = 'flex';
  const backIdx = navPath.length - 1;
  let html = `<span class="bc-back" onclick="navigateBreadcrumb(${backIdx})">← Volver</span>`;
  navPath.forEach((b, i) => {
    html += `<span class="bc-item" onclick="navigateBreadcrumb(${i})">${esc(b.name)}</span>`;
    html += `<span class="bc-sep">›</span>`;
  });
  html += `<span class="bc-item bc-current">${esc(currentBoard?.name || '')}</span>`;
  el.innerHTML = html;
}

async function selectBoard(id, focusNodeId) {
  currentBoard = await fetch(`${ECO_BAPI}/boards/${id}`).then(r => r.json());
  if (!currentBoard.cards) currentBoard.cards = currentBoard.nodes || [];
  if (!currentBoard.connections) currentBoard.connections = [];
  initParticles();
  await resolveAllRefs();
  if (focusNodeId) {
    const node = currentBoard.cards.find(c => c.id === focusNodeId);
    if (node) centerOnCard(node); else centerView();
  } else {
    centerView();
  }
  renderBoardTabs();
  document.getElementById('boardName').value = currentBoard.name;
  document.getElementById('emptyState').style.display = currentBoard.cards.length === 0 ? 'block' : 'none';
  closePanel();
  renderBreadcrumb();
}

async function resolveAllRefs() {
  if (!currentBoard) return;
  const allRefs = [];
  currentBoard.cards.forEach(c => {
    (c.refs || []).forEach(r => {
      const key = r.boardId + ':' + r.cardId;
      if (!refCache[key]) allRefs.push(r);
    });
  });
  if (allRefs.length === 0) return;
  const results = await fetch(`${ECO_BAPI}/resolve-refs`, { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ refs: allRefs }) }).then(r => r.json());
  results.forEach(r => { refCache[r.boardId + ':' + r.cardId] = r; });
}

async function createBoard() {
  const board = await fetch(`${ECO_BAPI}/boards`, { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ name: 'Nuevo Board' }) }).then(r => r.json());
  boards.push({ id: board.id, name: board.name, cardCount: 0 });
  await selectBoard(board.id);
}

async function deleteBoard(id) {
  if (!confirm('Eliminar este board?')) return;
  await fetch(`${ECO_BAPI}/boards/${id}`, { method: 'DELETE' });
  boards = boards.filter(b => b.id !== id);
  if (currentBoard && currentBoard.id === id) { currentBoard = null; autoSelect(); }
  else renderBoardTabs();
}

function renderBoardTabs() {
  const bar = document.getElementById('boardsBar');
  bar.innerHTML = boards.map(b =>
    `<div class="bs-board-tab ${currentBoard && b.id === currentBoard.id ? 'active' : ''}" onclick="navPath=[];location.hash='#'+'${b.id}'">
      ${esc(b.name)} <span class="tab-count">${b.cardCount || 0}</span>
    </div>`
  ).join('') + `<button class="bs-add-board" onclick="createBoard()">+ Board</button>`;
}

function centerView() {
  if (!currentBoard || currentBoard.cards.length === 0) { panX = 0; panY = 0; scale = 1; return; }
  const xs = currentBoard.cards.map(c => c.x);
  const ys = currentBoard.cards.map(c => c.y);
  const minX = Math.min(...xs), maxX = Math.max(...xs) + CARD_W;
  const minY = Math.min(...ys), maxY = Math.max(...ys) + CARD_H;
  const contentW = maxX - minX || 1, contentH = maxY - minY || 1;
  const pad = 80;
  scale = Math.min(1.2, (W - pad * 2) / contentW, (H - pad * 2) / contentH);
  scale = Math.max(0.15, scale);
  const cx = (minX + maxX) / 2, cy = (minY + maxY) / 2;
  panX = W / 2 - cx * scale;
  panY = H / 2 - cy * scale;
  document.getElementById('zoomLabel').textContent = Math.round(scale * 100) + '%';
}

// --- Particles ---
function initParticles() {
  particles = [];
  if (!currentBoard) return;
  currentBoard.connections.forEach(c => {
    for (let i = 0; i < 3; i++) particles.push({ connId: c.id, t: i / 3, speed: 0.0006 + Math.random() * 0.0005, size: 1.5 + Math.random() * 1.5 });
  });
}

// Card total height including sub-card rows
const PROJECT_ROW_H = 28;
function cardTotalH(c) {
  const refs = c.refs || [];
  let h = CARD_H;
  if (c.projectName) h += PROJECT_ROW_H + 4;
  if (refs.length > 0) h += 4 + refs.length * SUB_ROW_H + 8;
  return h;
}

// --- Connection hit testing ---
function connAt(sx, sy) {
  if (!currentBoard) return null;
  for (let i = currentBoard.connections.length - 1; i >= 0; i--) {
    const c = currentBoard.connections[i];
    const from = currentBoard.cards.find(cd => cd.id === c.from);
    const to = currentBoard.cards.find(cd => cd.id === c.to);
    if (!from || !to) continue;
    const [x1,y1] = toScreen(from.x+CARD_W/2, from.y+CARD_H/2);
    const [x2,y2] = toScreen(to.x+CARD_W/2, to.y+CARD_H/2);
    const dx=x2-x1, dist=Math.sqrt(dx*dx+(y2-y1)**2);
    const bend=Math.min(dist*.35,140);
    const cx1=x1+bend*Math.sign(dx||1), cy1=y1, cx2=x2-bend*Math.sign(dx||1), cy2=y2;
    for (let t=0; t<=1; t+=0.025) {
      const [px,py] = bezPt(x1,y1,cx1,cy1,cx2,cy2,x2,y2,t);
      if (Math.sqrt((sx-px)**2+(sy-py)**2) < 12) return c;
    }
  }
  return null;
}

// --- Drawing ---
function toScreen(x, y) { return [x * scale + panX, y * scale + panY]; }
function toWorld(sx, sy) { return [(sx - panX) / scale, (sy - panY) / scale]; }
function hex2rgba(hex, a) { const r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16); return `rgba(${r},${g},${b},${a})`; }
function rr(x, y, w, h, r) { ctx.beginPath(); ctx.roundRect(x, y, w, h, r); }
function truncT(text, maxW) { if (!text || ctx.measureText(text).width <= maxW) return text || ''; let t = text; while (t.length > 0 && ctx.measureText(t+'...').width > maxW) t = t.slice(0,-1); return t+'...'; }
function bezPt(x1,y1,cx1,cy1,cx2,cy2,x2,y2,t) { const m=1-t; return [m*m*m*x1+3*m*m*t*cx1+3*m*t*t*cx2+t*t*t*x2, m*m*m*y1+3*m*m*t*cy1+3*m*t*t*cy2+t*t*t*y2]; }

function drawGrid() {
  ctx.fillStyle = '#060609'; ctx.fillRect(0, 0, W, H);
  const grd = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, W*0.6);
  grd.addColorStop(0, 'rgba(201,169,78,0.012)'); grd.addColorStop(1, 'transparent');
  ctx.fillStyle = grd; ctx.fillRect(0, 0, W, H);
  const gap = 40 * scale; if (gap < 6) return;
  const ox = panX % gap, oy = panY % gap;
  ctx.fillStyle = `rgba(255,255,255,${Math.min(0.06, 0.02 + scale * 0.015)})`;
  for (let x = ox; x < W; x += gap) for (let y = oy; y < H; y += gap) ctx.fillRect(x-.5, y-.5, 1, 1);
}

function drawConnections() {
  if (!currentBoard) return;
  currentBoard.connections.forEach(c => {
    const from = currentBoard.cards.find(cd => cd.id === c.from);
    const to = currentBoard.cards.find(cd => cd.id === c.to);
    if (!from || !to) return;
    const isConnHover = c === hoverConn, isConnSel = c === selectedConn;
    const [x1, y1] = toScreen(from.x + CARD_W/2, from.y + CARD_H/2);
    const [x2, y2] = toScreen(to.x + CARD_W/2, to.y + CARD_H/2);
    const dx = x2-x1, dist = Math.sqrt(dx*dx+(y2-y1)**2);
    const bend = Math.min(dist * 0.35, 140);
    const cx1 = x1 + bend * Math.sign(dx||1), cy1 = y1;
    const cx2 = x2 - bend * Math.sign(dx||1), cy2 = y2;
    const fc = from.color || '#c9a94e', tc = to.color || '#c9a94e';
    ctx.save();
    const connAlpha = isConnSel ? 0.2 : isConnHover ? 0.14 : 0.08;
    const lineAlpha = isConnSel ? 0.6 : isConnHover ? 0.4 : 0.25;
    const lineW = isConnSel ? 2.5 : isConnHover ? 2 : 1.5;
    ctx.strokeStyle = hex2rgba(fc, connAlpha); ctx.lineWidth = isConnSel ? 14 : 10;
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.bezierCurveTo(cx1,cy1,cx2,cy2,x2,y2); ctx.stroke();
    ctx.strokeStyle = hex2rgba(fc, lineAlpha); ctx.lineWidth = lineW; ctx.setLineDash([6,5]);
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.bezierCurveTo(cx1,cy1,cx2,cy2,x2,y2); ctx.stroke();
    ctx.setLineDash([]);
    // Arrow
    const [ax,ay] = bezPt(x1,y1,cx1,cy1,cx2,cy2,x2,y2,0.87);
    const [bx,by] = bezPt(x1,y1,cx1,cy1,cx2,cy2,x2,y2,0.85);
    const ang = Math.atan2(ay-by,ax-bx);
    ctx.fillStyle = hex2rgba(tc, 0.4);
    ctx.beginPath(); ctx.moveTo(ax,ay);
    ctx.lineTo(ax-8*Math.cos(ang-.35),ay-8*Math.sin(ang-.35));
    ctx.lineTo(ax-8*Math.cos(ang+.35),ay-8*Math.sin(ang+.35));
    ctx.closePath(); ctx.fill();
    // Label
    if (c.label) {
      const [lx,ly] = bezPt(x1,y1,cx1,cy1,cx2,cy2,x2,y2,0.5);
      ctx.font = `500 ${Math.max(8,9.5*Math.min(scale,1.3))}px Figtree, sans-serif`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      const tw = ctx.measureText(c.label).width + 16;
      ctx.fillStyle = 'rgba(6,6,9,0.9)';
      rr(lx-tw/2, ly-11, tw, 22, 11); ctx.fill();
      ctx.strokeStyle = hex2rgba(fc, 0.2); ctx.lineWidth = 1;
      rr(lx-tw/2, ly-11, tw, 22, 11); ctx.stroke();
      ctx.fillStyle = 'rgba(255,255,255,0.55)'; ctx.fillText(c.label, lx, ly);
    }
    ctx.restore();
  });
  // Particles
  particles.forEach(p => {
    if (!currentBoard) return;
    const c = currentBoard.connections.find(cn => cn.id === p.connId);
    if (!c) return;
    const from = currentBoard.cards.find(cd => cd.id === c.from);
    const to = currentBoard.cards.find(cd => cd.id === c.to);
    if (!from || !to) return;
    p.t += p.speed; if (p.t > 1) p.t -= 1;
    const [x1,y1] = toScreen(from.x+CARD_W/2, from.y+CARD_H/2);
    const [x2,y2] = toScreen(to.x+CARD_W/2, to.y+CARD_H/2);
    const dx=x2-x1, dist=Math.sqrt(dx*dx+(y2-y1)**2), bend=Math.min(dist*.35,140);
    const cx1=x1+bend*Math.sign(dx||1), cy1=y1, cx2=x2-bend*Math.sign(dx||1), cy2=y2;
    const [px,py] = bezPt(x1,y1,cx1,cy1,cx2,cy2,x2,y2,p.t);
    const color = from.color || '#c9a94e';
    ctx.save(); ctx.shadowColor = color; ctx.shadowBlur = 8;
    ctx.beginPath(); ctx.arc(px,py,p.size,0,Math.PI*2);
    ctx.fillStyle = hex2rgba(color, 0.6); ctx.fill(); ctx.restore();
  });
}

function drawCards() {
  if (!currentBoard) return;
  const t = time;
  currentBoard.cards.forEach(c => {
    const refs = c.refs || [];
    const totalH = cardTotalH(c);
    const [x, y] = toScreen(c.x, c.y);
    const w = CARD_W * scale, h = totalH * scale, baseH = CARD_H * scale, r = CARD_R * scale;
    const isHover = c === hoverCard, isSel = c === selectedCard;
    const color = c.color || '#c9a94e';
    const pulse = 0.6 + 0.2 * Math.sin(t / 2000 + c.x * 0.01);
    const s = scale;

    ctx.save();
    // Outer glow
    if (isSel || isHover) {
      ctx.shadowColor = color; ctx.shadowBlur = 30;
      ctx.strokeStyle = hex2rgba(color, 0.2); ctx.lineWidth = 1;
      rr(x-3,y-3,w+6,h+6,r+3); ctx.stroke(); ctx.shadowBlur = 0;
    }
    // Ambient
    const ag = ctx.createRadialGradient(x+w/2,y+h/2,0,x+w/2,y+h/2,w*0.55);
    ag.addColorStop(0, hex2rgba(color, 0.035*pulse)); ag.addColorStop(1, 'transparent');
    ctx.fillStyle = ag; ctx.fillRect(x-w*.15,y-h*.2,w*1.3,h*1.4);
    // Body (full height including sub-cards)
    const bg = ctx.createLinearGradient(x,y,x,y+h);
    bg.addColorStop(0,'rgba(16,18,26,0.97)'); bg.addColorStop(1,'rgba(10,11,16,0.99)');
    ctx.fillStyle = bg; rr(x,y,w,h,r); ctx.fill();
    // Top bar
    const tg = ctx.createLinearGradient(x,y,x+w,y);
    tg.addColorStop(0,hex2rgba(color,0)); tg.addColorStop(0.2,hex2rgba(color,isSel?.9:.5*pulse));
    tg.addColorStop(0.8,hex2rgba(color,isSel?.9:.5*pulse)); tg.addColorStop(1,hex2rgba(color,0));
    ctx.fillStyle = tg; rr(x,y,w,2.5*s,[r,r,0,0]); ctx.fill();
    // Border
    ctx.strokeStyle = hex2rgba(color, isSel?.5:isHover?.3:.1); ctx.lineWidth = isSel?1.5:1;
    rr(x,y,w,h,r); ctx.stroke();

    const pad = 16 * s;
    const cx_ = x + pad, cw = w - pad * 2;

    // Hex icon
    const iconX = cx_ + 10*s, row1Y = y + 18*s;
    ctx.save(); ctx.translate(iconX, row1Y);
    const hexR = 9*s;
    ctx.rotate(t/8000+c.x*0.1); ctx.beginPath();
    for(let i=0;i<6;i++){const a=Math.PI/3*i;i===0?ctx.moveTo(hexR*Math.cos(a),hexR*Math.sin(a)):ctx.lineTo(hexR*Math.cos(a),hexR*Math.sin(a));}
    ctx.closePath(); ctx.strokeStyle=hex2rgba(color,.4*pulse); ctx.lineWidth=1.2; ctx.stroke();
    ctx.rotate(-t/4000); ctx.beginPath();
    for(let i=0;i<6;i++){const a=Math.PI/3*i;const hr=hexR*.5;i===0?ctx.moveTo(hr*Math.cos(a),hr*Math.sin(a)):ctx.lineTo(hr*Math.cos(a),hr*Math.sin(a));}
    ctx.closePath(); ctx.fillStyle=hex2rgba(color,.15); ctx.fill();
    ctx.beginPath(); ctx.arc(0,0,2.5*s,0,Math.PI*2); ctx.fillStyle=color; ctx.shadowColor=color; ctx.shadowBlur=6*s; ctx.fill(); ctx.shadowBlur=0;
    ctx.restore();

    // Name + Stage badge
    const nameX = iconX + 16*s;
    ctx.font = `600 ${Math.max(10,13*s)}px Outfit, sans-serif`;
    ctx.textAlign = 'left'; ctx.textBaseline = 'middle'; ctx.fillStyle = '#f0f0f2';
    const stageW = c.stage ? 50*s : 0;
    ctx.fillText(truncT(c.name || c.title || '', cw - 32*s - stageW), nameX, row1Y);
    if (c.stage && STAGE_LABELS[c.stage]) {
      const sc=STAGE_COLORS[c.stage]||'#888', sl=STAGE_LABELS[c.stage];
      ctx.font=`700 ${Math.max(7,8.5*s)}px Outfit, sans-serif`; const stw=ctx.measureText(sl).width+12*s;
      const stx=x+w-pad-stw, sty=row1Y-8*s;
      ctx.fillStyle=hex2rgba(sc,.15); rr(stx,sty,stw,16*s,8*s); ctx.fill();
      ctx.strokeStyle=hex2rgba(sc,.3); ctx.lineWidth=.8; rr(stx,sty,stw,16*s,8*s); ctx.stroke();
      ctx.fillStyle=sc; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(sl,stx+stw/2,sty+8*s);
    }

    // Description
    ctx.font = `400 ${Math.max(8,10*s)}px Figtree, sans-serif`;
    ctx.fillStyle = 'rgba(255,255,255,0.4)'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
    const desc = c.description || c.summary || '';
    ctx.fillText(truncT(desc, cw), cx_, row1Y + 20*s);

    // Separator + Metrics
    const sepY = row1Y + 34*s;
    ctx.strokeStyle='rgba(255,255,255,0.05)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(cx_,sepY); ctx.lineTo(x+w-pad,sepY); ctx.stroke();
    const metrics = c.metrics || [];
    if (metrics.length > 0) {
      const mc=Math.min(metrics.length,3), mw=cw/mc, mY=sepY+14*s;
      metrics.slice(0,3).forEach((m,i) => {
        const mx=cx_+mw*i;
        ctx.font=`600 ${Math.max(6,7.5*s)}px Outfit, sans-serif`; ctx.fillStyle='rgba(255,255,255,0.25)'; ctx.textAlign='left'; ctx.textBaseline='middle'; ctx.fillText((m.label||'').toUpperCase(),mx,mY);
        ctx.font=`600 ${Math.max(8,10.5*s)}px Figtree, sans-serif`; ctx.fillStyle=hex2rgba(color,.8); ctx.fillText(truncT(m.value||'',mw-6*s),mx,mY+13*s);
      });
    }

    // Active pulse dot
    if (c.active !== false) {
      const dx=x+w-8*s, dy=y+8*s, dp=2.5+Math.sin(t/600)*0.8;
      ctx.beginPath(); ctx.arc(dx,dy,dp*s,0,Math.PI*2); ctx.fillStyle=hex2rgba('#34d399',.5); ctx.fill();
      ctx.beginPath(); ctx.arc(dx,dy,1.5*s,0,Math.PI*2); ctx.fillStyle='#34d399'; ctx.fill();
    }

    // Connection count badge top-right
    const connCount = currentBoard.connections.filter(cn => cn.from === c.id || cn.to === c.id).length;
    if (connCount > 0) {
      const bx = x+w-12*s, by = y+12*s;
      ctx.beginPath(); ctx.arc(bx, by, 8*s, 0, Math.PI*2);
      ctx.fillStyle = hex2rgba(color, 0.15); ctx.fill();
      ctx.font = `700 ${Math.max(7,8*s)}px Outfit, sans-serif`;
      ctx.fillStyle = hex2rgba(color, 0.6);
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(connCount, bx, by);
    }

    // --- Project association row ---
    let projectRowY = null;
    if (c.projectName) {
      const prY = y + (CARD_H - 6) * s;
      projectRowY = prY;
      ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(x + 10*s, prY); ctx.lineTo(x + w - 10*s, prY); ctx.stroke();
      const rowH = PROJECT_ROW_H * s;
      const isHover = hoverProject === c;
      if (isHover) { ctx.fillStyle = 'rgba(201,169,78,0.06)'; rr(x+4*s, prY+2*s, w-8*s, rowH, 4*s); ctx.fill(); }
      // Folder icon
      const ix = cx_ + 2*s, iy = prY + 2*s + rowH/2;
      ctx.save(); ctx.strokeStyle = isHover ? 'var(--gold,#c9a94e)' : 'rgba(201,169,78,0.5)'; ctx.lineWidth = 1.2*s;
      const is = 5*s;
      ctx.beginPath(); ctx.moveTo(ix-is,iy-is*.6); ctx.lineTo(ix-is,iy+is*.6); ctx.lineTo(ix+is,iy+is*.6); ctx.lineTo(ix+is,iy-is*.3); ctx.lineTo(ix+is*.2,iy-is*.3); ctx.lineTo(ix,iy-is*.6); ctx.closePath(); ctx.stroke();
      ctx.restore();
      // Project name
      ctx.font = `600 ${Math.max(7,9*s)}px Figtree, sans-serif`;
      ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
      ctx.fillStyle = isHover ? '#c9a94e' : 'rgba(201,169,78,0.7)';
      ctx.fillText(truncT(c.projectName, cw - 40*s), cx_ + 16*s, iy);
      // Arrow
      ctx.fillStyle = isHover ? '#c9a94e' : 'rgba(201,169,78,0.35)';
      ctx.font = `400 ${Math.max(8,10*s)}px Figtree, sans-serif`;
      ctx.textAlign = 'right';
      ctx.fillText('>', x + w - pad, iy);
    }

    // --- Sub-card rows integrated inside card ---
    if (refs.length > 0) {
      const sepY = y + (CARD_H - 6 + (c.projectName ? PROJECT_ROW_H : 0)) * s;
      // Separator line
      ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(x + 10*s, sepY); ctx.lineTo(x + w - 10*s, sepY); ctx.stroke();

      let rowY = sepY + 4*s;
      refs.forEach((ref, idx) => {
        const key = ref.boardId + ':' + ref.cardId;
        const data = refCache[key] || {};
        const rc = data.color || '#888';
        const rowH = SUB_ROW_H * s;

        // Row background: hover highlight or subtle alternate
        const isRowHover = hoverRef && hoverRef.card === c && hoverRef.refIndex === idx;
        if (isRowHover) {
          ctx.fillStyle = 'rgba(255,255,255,0.06)';
          rr(x + 4*s, rowY, w - 8*s, rowH, 4*s); ctx.fill();
        } else if (idx % 2 === 0) {
          ctx.fillStyle = 'rgba(255,255,255,0.012)';
          rr(x + 4*s, rowY, w - 8*s, rowH, 4*s); ctx.fill();
        }

        // Color dot
        ctx.beginPath(); ctx.arc(cx_ + 4*s, rowY + rowH/2, 3.5*s, 0, Math.PI*2);
        ctx.fillStyle = rc; ctx.fill();

        // Title
        ctx.font = `500 ${Math.max(7,9.5*s)}px Figtree, sans-serif`;
        ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
        ctx.fillStyle = isRowHover ? '#fff' : (data.found !== false ? 'rgba(255,255,255,0.7)' : 'rgba(255,255,255,0.25)');
        const maxTitleW = cw - 80*s;
        ctx.fillText(truncT(data.title || '(no encontrada)', maxTitleW), cx_ + 14*s, rowY + rowH/2);

        // Board name badge right-aligned
        if (data.boardName) {
          ctx.font = `600 ${Math.max(5,6.5*s)}px Outfit, sans-serif`;
          ctx.fillStyle = hex2rgba(rc, 0.35);
          ctx.textAlign = 'right';
          ctx.fillText(truncT(data.boardName, 60*s), x + w - pad, rowY + rowH/2);
        }

        rowY += rowH;
      });
    }

    ctx.restore();
  });
}

function draw() {
  drawGrid();
  drawConnections();
  drawCards();
  if (connectMode && connectFrom && connectMX != null) {
    const [x1,y1] = toScreen(connectFrom.x+CARD_W/2, connectFrom.y+CARD_H/2);
    ctx.save(); ctx.strokeStyle = '#c9a94e'; ctx.lineWidth = 2; ctx.setLineDash([8,6]);
    ctx.shadowColor = '#c9a94e'; ctx.shadowBlur = 10;
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(connectMX,connectMY); ctx.stroke();
    ctx.restore();
  }
}

function animate(ts) { time = ts || 0; draw(); requestAnimationFrame(animate); }

// --- Interaction ---
function cardAt(sx, sy) {
  if (!currentBoard) return null;
  const [wx, wy] = toWorld(sx, sy);
  for (let i = currentBoard.cards.length - 1; i >= 0; i--) {
    const c = currentBoard.cards[i];
    const th = cardTotalH(c);
    if (wx >= c.x && wx <= c.x + CARD_W && wy >= c.y && wy <= c.y + th) return c;
  }
  return null;
}

// Returns {card, refIndex} if mouse is over a sub-card row, or null
function projectRowAt(sx, sy) {
  if (!currentBoard) return null;
  const [wx, wy] = toWorld(sx, sy);
  for (let i = currentBoard.cards.length - 1; i >= 0; i--) {
    const c = currentBoard.cards[i];
    if (!c.projectName) continue;
    if (wx < c.x || wx > c.x + CARD_W) continue;
    const prY = c.y + CARD_H - 6;
    if (wy >= prY && wy < prY + PROJECT_ROW_H + 4) return c;
  }
  return null;
}

function refRowAt(sx, sy) {
  if (!currentBoard) return null;
  const [wx, wy] = toWorld(sx, sy);
  for (let i = currentBoard.cards.length - 1; i >= 0; i--) {
    const c = currentBoard.cards[i];
    const refs = c.refs || [];
    if (refs.length === 0) continue;
    if (wx < c.x || wx > c.x + CARD_W) continue;
    const projOffset = c.projectName ? PROJECT_ROW_H : 0;
    const rowStartY = c.y + CARD_H - 2 + projOffset;
    for (let ri = 0; ri < refs.length; ri++) {
      const ry = rowStartY + ri * SUB_ROW_H;
      if (wy >= ry && wy < ry + SUB_ROW_H) return { card: c, refIndex: ri };
    }
  }
  return null;
}

function bindEvents() {
  canvas.addEventListener('mousedown', e => {
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
    const c = cardAt(sx, sy);
    if (connectMode) {
      if (c) {
        if (!connectFrom) { connectFrom = c; }
        else if (c !== connectFrom) {
          createConnection(connectFrom.id, c.id, '');
          connectMode = false; connectFrom = null;
          canvas.classList.remove('connecting');
          document.getElementById('btnConn').classList.remove('active');
        }
      }
      return;
    }
    // Check if clicking a project row or sub-card row — don't start drag
    const projHit = projectRowAt(sx, sy);
    if (projHit) return;
    const refHit = refRowAt(sx, sy);
    if (refHit) return;
    if (c) {
      dragCard = c; didDrag = false;
      dragOffX = sx/scale - c.x - panX/scale;
      dragOffY = sy/scale - c.y - panY/scale;
      canvas.classList.add('dragging');
    } else {
      isPanning = true; panSX = e.clientX; panSY = e.clientY; panSPX = panX; panSPY = panY;
      canvas.classList.add('dragging');
    }
  });

  canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
    if (connectMode) { connectMX = sx; connectMY = sy; }
    if (dragCard) {
      const nx = sx/scale - dragOffX - panX/scale, ny = sy/scale - dragOffY - panY/scale;
      if (Math.abs(nx - dragCard.x) > 3 || Math.abs(ny - dragCard.y) > 3) didDrag = true;
      dragCard.x = nx; dragCard.y = ny;
    } else if (isPanning) {
      if (Math.abs(e.clientX - panSX) > 3 || Math.abs(e.clientY - panSY) > 3) didDrag = true;
      panX = panSPX + (e.clientX - panSX); panY = panSPY + (e.clientY - panSY);
    } else {
      // Check project row first, then sub-card rows, then card, then connection
      const pr_ = projectRowAt(sx, sy);
      if (pr_) {
        hoverProject = pr_; hoverRef = null; hoverCard = null; hoverConn = null;
        canvas.style.cursor = 'pointer';
      } else {
        hoverProject = null;
        const rr_ = refRowAt(sx, sy);
        if (rr_) {
          hoverRef = rr_; hoverCard = null; hoverConn = null;
          canvas.style.cursor = 'pointer';
        } else {
          hoverRef = null;
          const c = cardAt(sx, sy);
          if (c) { hoverCard = c; hoverConn = null; canvas.style.cursor = 'pointer'; }
          else { hoverCard = null; const cn = connAt(sx, sy); hoverConn = cn; canvas.style.cursor = cn ? 'pointer' : 'grab'; }
        }
      }
    }
  });

  canvas.addEventListener('mouseup', e => {
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
    // Check project row click
    if (!connectMode) {
      // Check project row click
      const projHit = projectRowAt(sx, sy);
      if (projHit && !didDrag) {
        window.location.href = 'projects?project=' + encodeURIComponent(projHit.projectName);
        isPanning = false; didDrag = false; canvas.classList.remove('dragging');
        return;
      }
      // Check sub-card row click
      const refHit = refRowAt(sx, sy);
      if (refHit) {
        navigateToRef(refHit.card, refHit.refIndex);
        isPanning = false; didDrag = false; canvas.classList.remove('dragging');
        return;
      }
    }
    if (dragCard) {
      saveCardPos(dragCard);
      if (!didDrag) {
        // If node has a sub-board, drill into it
        openPanel(dragCard);
      }
      dragCard = null;
    } else if (isPanning && !didDrag) {
      const conn = connAt(sx, sy);
      if (conn) openConnPanel(conn);
    }
    isPanning = false; didDrag = false; canvas.classList.remove('dragging');
  });

  canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left, my = e.clientY - rect.top;
    const [wx, wy] = toWorld(mx, my);
    scale = Math.max(0.2, Math.min(4, scale * (e.deltaY > 0 ? 0.92 : 1.08)));
    panX = mx - wx * scale; panY = my - wy * scale;
    document.getElementById('zoomLabel').textContent = Math.round(scale * 100) + '%';
  }, { passive: false });

  document.getElementById('btnAdd').addEventListener('click', createCard);
  document.getElementById('btnConn').addEventListener('click', () => {
    connectMode = !connectMode; connectFrom = null;
    canvas.classList.toggle('connecting', connectMode);
    document.getElementById('btnConn').classList.toggle('active', connectMode);
  });
  document.getElementById('btnReset').addEventListener('click', () => { centerView(); scale = 1; document.getElementById('zoomLabel').textContent = '100%'; });
  document.getElementById('spClose').addEventListener('click', closePanel);
  document.getElementById('boardName').addEventListener('change', renameboard);
  document.getElementById('cpClose').addEventListener('click', closeConnPanel);
  document.getElementById('cpDelete').addEventListener('click', deleteConn);
  document.getElementById('spAddRef').addEventListener('click', openRefPicker);
  document.getElementById('rpCancel').addEventListener('click', closeRefPicker);
  document.getElementById('rpSearch').addEventListener('input', filterRefPicker);
  ['cpLabel','cpDetail'].forEach(id => {
    document.getElementById(id).addEventListener('input', scheduleConnSave);
  });

  const optsBtn = document.getElementById('optsBtn');
  const optsMenu = document.getElementById('optsMenu');
  optsBtn.addEventListener('click', e => { e.stopPropagation(); optsMenu.classList.toggle('open'); optsBtn.classList.toggle('open'); });
  document.addEventListener('click', () => { optsMenu.classList.remove('open'); optsBtn.classList.remove('open'); });
  optsMenu.addEventListener('click', e => e.stopPropagation());

  ['spName','spDesc','spStage','spRevenue','spAgent','spObj','spNotes'].forEach(id => {
    document.getElementById(id).addEventListener('input', scheduleSave);
  });
  document.getElementById('spStage').addEventListener('change', scheduleSave);
  document.getElementById('spMetricAdd').addEventListener('click', addMetric);
}

// --- Card Panel ---
// --- Ecosystem-specific helpers ---
let allTasks = null;
async function ensureTasks() { if(!allTasks) allTasks = await fetch('api/tasks').then(r=>r.json()); return allTasks; }
function getNodeTasks(n) {
  if(!allTasks) return [];
  const name = (n.projectName || '').toLowerCase(); if(!name) return [];
  return allTasks.filter(t => t.project && t.project.toLowerCase() === name)
    .sort((a,b) => ({'in-progress':0,todo:1,blocked:2,done:3}[a.status]??1) - ({'in-progress':0,todo:1,blocked:2,done:3}[b.status]??1));
}
const STAGE_COLORS = {idea:'#888',desarrollo:'#3498db',mvp:'#e67e22',activo:'#2ecc71',escalando:'#c9a94e',escritura:'#9b59b6',pausado:'#555'};
const STAGE_LABELS = {idea:'IDEA',desarrollo:'DEV',mvp:'MVP',activo:'ACTIVO',escalando:'SCALE',escritura:'ESCR',pausado:'PAUSA'};
const STATUS_COLORS = {todo:'#888','in-progress':'#3498db',blocked:'#f87171',done:'#2ecc71'};
const STATUS_LABELS = {todo:'Pendiente','in-progress':'En progreso',blocked:'Bloqueado',done:'Hecho'};

function renderMetrics() {
  if(!selectedCard) return;
  const el = document.getElementById('spMetrics');
  el.innerHTML = (selectedCard.metrics||[]).map((m,i) =>
    `<span class="sp-tag" style="gap:6px"><strong style="opacity:0.5">${esc(m.label)}</strong> ${esc(m.value)}<button onclick="removeMetric(${i})">x</button></span>`
  ).join('') || '<span style="color:var(--text-tertiary);font-size:0.72rem">Sin metricas</span>';
}
function addMetric() {
  if(!selectedCard) return;
  const l=document.getElementById('spMetricLabel'), v=document.getElementById('spMetricVal');
  if(!l.value.trim()) return;
  if(!selectedCard.metrics) selectedCard.metrics=[];
  selectedCard.metrics.push({label:l.value.trim(),value:v.value.trim()}); l.value=''; v.value='';
  renderMetrics(); scheduleSave();
}
window.removeMetric = function(i) { if(!selectedCard) return; selectedCard.metrics.splice(i,1); renderMetrics(); scheduleSave(); };

async function renderProjectAssoc(c) {
  const wrap = document.getElementById('spProjectWrap');
  const taskSection = document.getElementById('spTaskSection');
  if (c.projectName) {
    wrap.innerHTML = `<div class="sp-conn-item" style="border-left:3px solid var(--gold);padding-left:10px;margin:4px 0">
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="var(--gold)" stroke-width="2" style="flex-shrink:0"><rect x="2" y="3" width="20" height="18" rx="2"/><path d="M8 7h8M8 12h8M8 17h4"/></svg>
      <strong style="flex:1">${esc(c.projectName)}</strong>
      <span class="del" onclick="unlinkProject()" style="opacity:0.6;cursor:pointer;color:var(--red);font-size:14px" title="Des-asociar">x</span>
    </div>`;
    taskSection.style.display = 'block';
    await ensureTasks();
    renderTaskList(c);
  } else {
    wrap.innerHTML = `<button onclick="openProjectPicker()" style="margin-top:4px;background:var(--gold-dim);color:var(--gold);border:none;padding:8px 14px;border-radius:var(--radius-sm);cursor:pointer;font-family:var(--font-body);font-size:0.78rem;font-weight:600;transition:all .2s;width:100%">+ Asociar proyecto</button>`;
    taskSection.style.display = 'none';
  }
}

window.unlinkProject = function() {
  if (!selectedCard) return;
  selectedCard.projectName = '';
  renderProjectAssoc(selectedCard);
  scheduleSave();
};

window.openProjectPicker = async function() {
  let projects = [];
  try { projects = await fetch('api/projects').then(r => r.json()); } catch(e) {}
  const wrap = document.getElementById('spProjectWrap');
  wrap.innerHTML = `<div style="margin-top:4px">
    <div style="display:flex;flex-direction:column;gap:2px;max-height:200px;overflow-y:auto;background:var(--bg-base);border:1px solid var(--border);border-radius:var(--radius-sm);padding:6px">
      ${projects.map(p => `<div class="sp-conn-item" style="cursor:pointer;padding:8px 10px" onclick="pickProject('${esc(p)}')">${esc(p)}</div>`).join('')}
      ${projects.length === 0 ? '<span style="color:var(--text-tertiary);font-size:0.78rem;padding:8px 10px">Sin proyectos disponibles</span>' : ''}
    </div>
    <button onclick="renderProjectAssoc(selectedCard)" style="margin-top:6px;background:none;border:1px solid var(--border);color:var(--text-tertiary);padding:6px 12px;border-radius:var(--radius-sm);cursor:pointer;font-family:var(--font-body);font-size:0.72rem;width:100%">Cancelar</button>
  </div>`;
};

window.pickProject = function(name) {
  if (!selectedCard) return;
  selectedCard.projectName = name;
  renderProjectAssoc(selectedCard);
  scheduleSave();
};

function renderTaskList(n) {
  const tasks = getNodeTasks(n);
  document.getElementById('spTaskLabel').textContent = `Tareas (${tasks.length})`;
  const el = document.getElementById('spTaskList');
  const link = document.getElementById('spTaskLink');
  if(!tasks.length) { el.innerHTML='<span style="color:var(--text-tertiary);font-size:0.72rem">Sin tareas asociadas</span>'; link.style.display='none'; return; }
  el.innerHTML = tasks.slice(0,15).map(t => {
    const sc=STATUS_COLORS[t.status]||'#888', sl=STATUS_LABELS[t.status]||t.status;
    return `<div class="sp-conn-item" style="cursor:default"><span style="width:8px;height:8px;border-radius:50%;background:${sc};flex-shrink:0"></span><span style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">${esc(t.title||'')}</span><span style="font-size:0.6rem;color:${sc};font-weight:600;font-family:var(--font-heading);text-transform:uppercase;letter-spacing:1px">${sl}</span></div>`;
  }).join('') + (tasks.length>15?`<div style="padding:4px 10px;font-size:0.7rem;color:var(--text-tertiary)">+ ${tasks.length-15} mas</div>`:'');
  link.style.display='block'; link.href='projects?project='+encodeURIComponent(n.projectName||n.name);
}

async function openPanel(c) {
  closeConnPanel();
  selectedCard = c;
  await ensureTasks();
  document.getElementById('spTitle').textContent = c.name || 'Nodo';
  document.getElementById('spName').value = c.name || '';
  document.getElementById('spDesc').value = c.description || '';
  document.getElementById('spStage').value = c.stage || 'idea';
  document.getElementById('spRevenue').value = c.revenue || '';
  document.getElementById('spAgent').value = c.agent || '';
  document.getElementById('spObj').value = c.objective || '';
  document.getElementById('spNotes').value = c.notes || '';
  renderColorSwatches(c.color);
  renderMetrics();
  renderProjectAssoc(c);
  renderRefs();
  renderConns();
  // Footer
  const footer = document.querySelector('#sidePanel .sp-footer');
  footer.innerHTML = `<button class="btn-del" onclick="deleteCard()">Eliminar idea</button>`;
  document.getElementById('sidePanel').classList.add('open');
}

function closePanel() { document.getElementById('sidePanel').classList.remove('open'); selectedCard = null; }

function renderColorSwatches(active) {
  document.getElementById('spColors').innerHTML = COLORS.map(c =>
    `<div class="color-swatch ${c===active?'active':''}" style="background:${c}" onclick="pickColor('${c}')"></div>`
  ).join('');
}
window.pickColor = function(c) { if (!selectedCard) return; selectedCard.color = c; renderColorSwatches(c); scheduleSave(); };

function renderRefs() {
  if (!selectedCard) return;
  const refs = selectedCard.refs || [];
  const el = document.getElementById('spRefs');
  if (!refs.length) { el.innerHTML = '<span style="color:var(--text-tertiary);font-size:0.75rem">Sin sub-nodos</span>'; return; }
  el.innerHTML = refs.map((r, i) => {
    const key = r.boardId + ':' + r.cardId;
    const data = refCache[key] || {};
    return `<div class="sp-conn-item" style="border-left:3px solid ${data.color||'#888'};padding-left:10px">
      <div style="flex:1;min-width:0">
        <div style="font-size:0.6rem;color:var(--text-tertiary);font-family:var(--font-heading);text-transform:uppercase;letter-spacing:1.5px">${esc(data.boardName||'?')}</div>
        <strong>${esc(data.title||'?')}</strong>
      </div>
      <span class="del" onclick="removeRef(${i})">x</span>
    </div>`;
  }).join('');
}

window.removeRef = async function(i) {
  if (!selectedCard || !currentBoard) return;
  selectedCard.refs.splice(i, 1);
  await fetch(`${ECO_BAPI}/boards/${currentBoard.id}/nodes/${selectedCard.id}`, { method: 'PUT', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ refs: selectedCard.refs }) });
  renderRefs();
};

function renderConns() {
  if (!selectedCard || !currentBoard) return;
  const conns = currentBoard.connections.filter(c => c.from === selectedCard.id || c.to === selectedCard.id);
  const el = document.getElementById('spConns');
  if (!conns.length) { el.innerHTML = '<span style="color:var(--text-tertiary);font-size:0.75rem">Sin conexiones</span>'; return; }
  el.innerHTML = conns.map(c => {
    const otherId = c.from === selectedCard.id ? c.to : c.from;
    const other = currentBoard.cards.find(cd => cd.id === otherId);
    const dir = c.from === selectedCard.id ? '&rarr;' : '&larr;';
    return `<div class="sp-conn-item">${dir} <strong>${other?.name||other?.title||'?'}</strong> <span style="color:var(--text-tertiary);font-size:0.72rem">${c.label||''}</span><span class="del" onclick="delConn('${c.id}')">x</span></div>`;
  }).join('');
}
window.delConn = async function(id) {
  if (!currentBoard) return;
  await fetch(`${ECO_BAPI}/boards/${currentBoard.id}/connections/${id}`, { method: 'DELETE' });
  currentBoard.connections = currentBoard.connections.filter(c => c.id !== id);
  particles = particles.filter(p => p.connId !== id);
  renderConns();
};

window.deleteCard = async function() {
  if (!selectedCard || !currentBoard || !confirm('Eliminar este nodo?')) return;
  await fetch(`${ECO_BAPI}/boards/${currentBoard.id}/nodes/${selectedCard.id}`, { method: 'DELETE' });
  currentBoard.cards = currentBoard.cards.filter(c => c.id !== selectedCard.id);
  currentBoard.connections = currentBoard.connections.filter(c => c.from !== selectedCard.id && c.to !== selectedCard.id);
  initParticles(); closePanel();
  document.getElementById('emptyState').style.display = currentBoard.cards.length === 0 ? 'block' : 'none';
};

function scheduleSave() { clearTimeout(saveTimer); saveTimer = setTimeout(savePanel, 400); }

async function savePanel() {
  if (!selectedCard || !currentBoard) return;
  const body = {
    name: document.getElementById('spName').value,
    description: document.getElementById('spDesc').value,
    stage: document.getElementById('spStage').value,
    revenue: document.getElementById('spRevenue').value,
    agent: document.getElementById('spAgent').value,
    projectName: selectedCard.projectName || '',
    objective: document.getElementById('spObj').value,
    notes: document.getElementById('spNotes').value,
    color: selectedCard.color,
    metrics: selectedCard.metrics || [],
  };
  Object.assign(selectedCard, body);
  document.getElementById('spTitle').textContent = body.name || 'Nodo';
  await fetch(`${ECO_BAPI}/boards/${currentBoard.id}/nodes/${selectedCard.id}`, { method: 'PUT', headers: {'Content-Type':'application/json'}, body: JSON.stringify(body) });
  const saved = document.getElementById('spSaved');
  saved.classList.add('show'); setTimeout(() => saved.classList.remove('show'), 1500);
}

async function saveCardPos(c) {
  if (!currentBoard) return;
  await fetch(`${ECO_BAPI}/boards/${currentBoard.id}/nodes/${c.id}`, { method: 'PUT', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ x: Math.round(c.x), y: Math.round(c.y) }) });
}

async function createCard() {
  if (!currentBoard) { await createBoard(); }
  const card = await fetch(`${ECO_BAPI}/boards/${currentBoard.id}/nodes`, { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({}) }).then(r => r.json());
  currentBoard.cards.push(card);
  document.getElementById('emptyState').style.display = 'none';
  openPanel(card);
}

async function createConnection(fromId, toId, label) {
  if (!currentBoard) return;
  const conn = await fetch(`${ECO_BAPI}/boards/${currentBoard.id}/connections`, { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ from: fromId, to: toId, label }) }).then(r => r.json());
  currentBoard.connections.push(conn);
  for (let i = 0; i < 3; i++) particles.push({ connId: conn.id, t: i/3, speed: .0006+Math.random()*.0005, size: 1.5+Math.random()*1.5 });
  openConnPanel(conn);
}

// --- Ref Picker ---
let refPickerAllCards = [];

async function openRefPicker() {
  if (!selectedCard) return;
  // Load all boards with full data
  refPickerAllCards = [];
  for (const b of boards) {
    if (b.id === currentBoard.id) {
      // Use current board cards (exclude self)
      currentBoard.cards.forEach(c => {
        if (c.id !== selectedCard.id) refPickerAllCards.push({ boardId: b.id, boardName: b.name, cardId: c.id, title: c.name||c.title, summary: c.description||c.summary, color: c.color });
      });
    } else {
      const full = await fetch(`${ECO_BAPI}/boards/${b.id}`).then(r => r.json());
      (full.cards || full.nodes || []).forEach(c => {
        refPickerAllCards.push({ boardId: b.id, boardName: b.name, cardId: c.id, title: c.name||c.title, summary: c.description||c.summary, color: c.color });
      });
    }
  }
  document.getElementById('rpSearch').value = '';
  renderRefPickerList('');
  document.getElementById('refPickerOverlay').classList.add('open');
}

function closeRefPicker() { document.getElementById('refPickerOverlay').classList.remove('open'); }

function filterRefPicker() {
  renderRefPickerList(document.getElementById('rpSearch').value.toLowerCase());
}

function renderRefPickerList(filter) {
  const existing = (selectedCard.refs || []).map(r => r.boardId + ':' + r.cardId);
  const filtered = refPickerAllCards.filter(c => {
    if (existing.includes(c.boardId + ':' + c.cardId)) return false;
    if (!filter) return true;
    return (c.title||'').toLowerCase().includes(filter) || (c.summary||'').toLowerCase().includes(filter) || (c.boardName||'').toLowerCase().includes(filter);
  });
  // Group by board
  const grouped = {};
  filtered.forEach(c => {
    if (!grouped[c.boardId]) grouped[c.boardId] = { name: c.boardName, cards: [] };
    grouped[c.boardId].cards.push(c);
  });
  const el = document.getElementById('rpList');
  if (Object.keys(grouped).length === 0) { el.innerHTML = '<p style="text-align:center;color:var(--text-tertiary);font-size:0.8rem;padding:20px">No hay ideas disponibles</p>'; return; }
  el.innerHTML = Object.entries(grouped).map(([bid, g]) =>
    `<div class="rp-board-name">${esc(g.name)}</div>` +
    g.cards.map(c => {
      return `<div class="rp-card" onclick="pickRef('${c.boardId}','${c.cardId}')">
        <div class="rp-dot" style="background:${c.color||'#888'}"></div>
        <div class="rp-info">
          <div class="rp-title">${esc(c.title||'Sin titulo')}</div>
          <div class="rp-summary">${esc(c.summary||'')}</div>
        </div>
      </div>`;
    }).join('')
  ).join('');
}

window.pickRef = async function(boardId, cardId) {
  if (!selectedCard || !currentBoard) return;
  if (!selectedCard.refs) selectedCard.refs = [];
  selectedCard.refs.push({ boardId, cardId });
  // Resolve immediately
  const key = boardId + ':' + cardId;
  if (!refCache[key]) {
    const results = await fetch(`${ECO_BAPI}/resolve-refs`, { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ refs: [{ boardId, cardId }] }) }).then(r => r.json());
    results.forEach(r => { refCache[r.boardId + ':' + r.cardId] = r; });
  }
  await fetch(`${ECO_BAPI}/boards/${currentBoard.id}/nodes/${selectedCard.id}`, { method: 'PUT', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ refs: selectedCard.refs }) });
  closeRefPicker();
  renderRefs();
};

// --- Navigation ---
function centerOnCard(card) {
  const cx = card.x + CARD_W / 2;
  const cy = card.y + cardTotalH(card) / 2;
  // Animate pan to center the card
  const targetPanX = W / 2 - cx * scale;
  const targetPanY = H / 2 - cy * scale;
  const startPanX = panX, startPanY = panY;
  const start = performance.now();
  const duration = 400;
  function step(now) {
    const t = Math.min(1, (now - start) / duration);
    const ease = t < 0.5 ? 2*t*t : 1-Math.pow(-2*t+2,2)/2; // easeInOutQuad
    panX = startPanX + (targetPanX - startPanX) * ease;
    panY = startPanY + (targetPanY - startPanY) * ease;
    if (t < 1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

async function navigateToRef(parentCard, refIndex) {
  const ref = (parentCard.refs || [])[refIndex];
  if (!ref) return;
  closePanel(); closeConnPanel();

  if (ref.boardId === currentBoard.id) {
    // Same board - find and center the card
    const target = currentBoard.cards.find(c => c.id === ref.cardId);
    if (target) {
      centerOnCard(target);
      // Brief highlight then open panel
      selectedCard = target;
      setTimeout(() => openPanel(target), 450);
    }
  } else {
    // Different board - drill into it and center on the target card
    drillIntoBoard(ref.boardId, parentCard.id, ref.cardId);
  }
}

// --- Connection Panel ---
function openConnPanel(conn) {
  closePanel();
  selectedConn = conn;
  const from = currentBoard.cards.find(c => c.id === conn.from);
  const to = currentBoard.cards.find(c => c.id === conn.to);
  document.getElementById('cpTitle').textContent = conn.label || 'Conexion';
  document.getElementById('cpFrom').textContent = from?.name || from?.title || '?';
  document.getElementById('cpTo').textContent = to?.name || to?.title || '?';
  document.getElementById('cpLabel').value = conn.label || '';
  document.getElementById('cpDetail').value = conn.detail || '';
  document.getElementById('connPanel').classList.add('open');
}
function closeConnPanel() { document.getElementById('connPanel').classList.remove('open'); selectedConn = null; }
function scheduleConnSave() { clearTimeout(connSaveTimer); connSaveTimer = setTimeout(saveConnPanel, 400); }
async function saveConnPanel() {
  if (!selectedConn || !currentBoard) return;
  const body = { label: document.getElementById('cpLabel').value, detail: document.getElementById('cpDetail').value };
  selectedConn.label = body.label; selectedConn.detail = body.detail;
  document.getElementById('cpTitle').textContent = body.label || 'Conexion';
  await fetch(`${ECO_BAPI}/boards/${currentBoard.id}/connections/${selectedConn.id}`, { method: 'PUT', headers: {'Content-Type':'application/json'}, body: JSON.stringify(body) });
  const saved = document.getElementById('cpSaved');
  saved.classList.add('show'); setTimeout(() => saved.classList.remove('show'), 1500);
}
async function deleteConn() {
  if (!selectedConn || !currentBoard || !confirm('Eliminar esta conexion?')) return;
  await fetch(`${ECO_BAPI}/boards/${currentBoard.id}/connections/${selectedConn.id}`, { method: 'DELETE' });
  currentBoard.connections = currentBoard.connections.filter(c => c.id !== selectedConn.id);
  particles = particles.filter(p => p.connId !== selectedConn.id);
  closeConnPanel();
}

// --- Board operations ---
window.renameboardPrompt = function() {
  if (!currentBoard) return;
  const name = prompt('Nombre del board:', currentBoard.name);
  if (name === null || !name.trim()) return;
  document.getElementById('boardName').value = name.trim();
  renameboard();
  document.getElementById('optsMenu').classList.remove('open'); document.getElementById('optsBtn').classList.remove('open');
};
window.deleteBoardConfirm = function() {
  if (!currentBoard) return;
  document.getElementById('optsMenu').classList.remove('open'); document.getElementById('optsBtn').classList.remove('open');
  if (!confirm('Eliminar "' + currentBoard.name + '" y todas sus ideas?')) return;
  deleteBoard(currentBoard.id);
};
window.duplicateBoard = async function() {
  if (!currentBoard) return;
  document.getElementById('optsMenu').classList.remove('open'); document.getElementById('optsBtn').classList.remove('open');
  const newBoard = await fetch(`${ECO_BAPI}/boards`, { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ name: currentBoard.name + ' (copia)' }) }).then(r => r.json());
  const idMap = {};
  for (const card of currentBoard.cards) {
    const nc = await fetch(`${ECO_BAPI}/boards/${newBoard.id}/nodes`, { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ ...card, id: undefined }) }).then(r => r.json());
    idMap[card.id] = nc.id;
  }
  for (const conn of currentBoard.connections) {
    if (idMap[conn.from] && idMap[conn.to]) {
      await fetch(`${ECO_BAPI}/boards/${newBoard.id}/connections`, { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ from: idMap[conn.from], to: idMap[conn.to], label: conn.label, detail: conn.detail }) });
    }
  }
  await loadBoards(); await selectBoard(newBoard.id);
};
async function renameboard() {
  if (!currentBoard) return;
  const name = document.getElementById('boardName').value;
  await fetch(`${ECO_BAPI}/boards/${currentBoard.id}`, { method: 'PUT', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ name }) });
  currentBoard.name = name;
  const b = boards.find(b => b.id === currentBoard.id); if (b) b.name = name;
  renderBoardTabs();
}

init();
initSidebar();
</script>
</div>
</body>
</html>
